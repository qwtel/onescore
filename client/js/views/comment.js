// Generated by CoffeeScript 1.3.3
(function() {

  _.extend(Template.comment, {
    events: {
      'click .reply': function(e) {
        if (!e.isPropagationStopped()) {
          e.stopPropagation();
          Session.toggle('addComment', this._id);
          Session.set('editComment', null);
          Meteor.flush();
          return window.focusById("reply-" + this._id);
        }
      },
      'click .edit': function(e) {
        if (!e.isPropagationStopped()) {
          e.stopPropagation();
          Session.set('addComment', null);
          Session.toggle('editComment', this._id);
          Meteor.flush();
          return window.focusById("edit-" + this._id);
        }
      },
      'click .vote': function(e) {
        var $t, up;
        if (!e.isPropagationStopped()) {
          e.stopPropagation();
          $t = $(e.target).closest('.vote');
          up = $t.data('up');
          return Meteor.call('vote', 'comments', this._id, up);
        }
      },
      'click .remove': function(e) {
        if (!e.isPropagationStopped()) {
          e.stopPropagation();
          return Comments.remove(this._id);
        }
      },
      'click .unexpand': function(e) {
        if (!e.isPropagationStopped()) {
          e.stopPropagation();
          return Session.push('unexpand', this._id, true);
        }
      },
      'mouseover .highlight': function(e) {
        if (!e.isPropagationStopped()) {
          e.stopPropagation();
          return $(e.target).closest('.comment').addClass('hover');
        }
      },
      'mouseleave .highlight': function(e) {
        if (!e.isPropagationStopped()) {
          e.stopPropagation();
          return $(e.target).closest('.comment').removeClass('hover');
        }
      }
    },
    unexpand: function() {
      var field;
      Session.get('redraw');
      field = Session.get('unexpand');
      if (field) {
        return field[this._id];
      }
      return false;
    },
    user: function() {
      return Meteor.users.findOne(this.user);
    },
    mention: function() {
      if (this.mention) {
        return Meteor.users.findOne(this.mention);
      }
    },
    verb: function() {
      if (this.parent != null) {
        return 'replied';
      }
      return 'commented';
    },
    hidden: function() {
      return false;
    },
    nested: function() {
      var parent;
      parent = Session.get('parent');
      if (parent) {
        if (this.level - 1 > Session.get('level')) {
          return 'nested';
        } else {
          return '';
        }
      } else {
        if (this.level > Session.get('level')) {
          return 'nested';
        } else {
          return '';
        }
      }
    },
    addLineBreaks: function(text) {
      text = _.escape(text);
      return text.replace('\n', '<br>');
    },
    voted: function(state) {
      var vote;
      state = state === 'up' ? true : false;
      if (Meteor.user()) {
        vote = Votes.findOne({
          user: Meteor.user()._id,
          entity: this._id
        });
        if (vote && vote.up === state) {
          return 'active';
        }
      }
      return '';
    },
    cutoff: function() {
      var parent;
      parent = Session.get('parent');
      if (parent) {
        return this.level > Session.get('level') + 4;
      } else {
        return this.level > Session.get('level') + 3;
      }
    },
    replies: function() {
      var c, data, sel, sort;
      sel = Template.comments.select(this._id);
      sort = Session.get('sort');
      switch (sort) {
        case 'hot':
          data = {
            hot: -1
          };
          break;
        case 'cool':
          data = {
            hot: 1
          };
          break;
        case 'new':
          data = {
            date: -1
          };
          break;
        case 'old':
          data = {
            date: 1
          };
          break;
        case 'best':
          data = {
            best: -1
          };
          break;
        case 'worst':
          data = {
            best: 1
          };
      }
      c = Comments.find(sel, {
        sort: data
      });
      return c;
    }
  });

}).call(this);
