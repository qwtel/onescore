// Generated by CoffeeScript 1.3.3
(function() {
  var calculateScore, countVotes, hotScore, naiveScore, table, updateScore, wilsonScore;

  table = {};

  Meteor.startup(function() {
    table = {
      titles: Titles,
      achievements: Achievements,
      accomplishments: Accomplishments,
      comments: Comments
    };
    Meteor.users.find().observe({
      added: function(user) {
        var options, url,
          _this = this;
        url = "https://graph.facebook.com/" + user.services.facebook.id;
        options = {
          params: {
            access_token: user.services.facebook.accessToken
          }
        };
        return Meteor.http.get(url, options, function(error, res) {
          return Meteor.users.update(user._id, {
            $set: {
              username: res.data.username,
              bio: res.data.bio,
              location: res.data.location.name
            }
          });
        });
      }
    });
    Achievements.find().observe({
      added: function(achievement) {
        return Achievements.update(achievement._id, {
          $set: {
            date: new Date()
          }
        });
      }
    });
    return Comments.find().observe({
      added: function(comment) {
        return Comments.update(comment._id, {
          $set: {
            date: new Date()
          }
        });
      }
    });
  });

  countVotes = function(id, up) {
    return Votes.find({
      entity: id,
      up: up
    }).count();
  };

  calculateScore = function(id) {
    var down, score, up;
    up = countVotes(id, true);
    down = countVotes(id, false);
    return score = {
      naive: naiveScore(up, down),
      wilson: wilsonScore(up, up + down),
      hote: hotScore(up, down, Date())
    };
  };

  naiveScore = function(up, down) {
    return up - down;
  };

  wilsonScore = function(pos, n) {
    var phat, z;
    if (n === 0) {
      return 0;
    }
    z = 1.96;
    phat = pos / n;
    return (phat + z * z / (2 * n) - z * Math.sqrt((phat * (1 - phat) + z * z / (4 * n)) / n)) / (1 + z * z / n);
  };

  hotScore = function(up, down, date) {
    var s;
    s = naiveScore(up, down);
    return 3;
  };

  updateScore = function(collection, id, score, callback) {
    return collection.update(id, {
      $set: {
        score: score.naive,
        best: score.wilson,
        hot: score.hot
      }
    }, callback);
  };

  Meteor.methods({
    vote: function(collection, entity, up) {
      var callback, data, score, vote;
      data = {
        user: this.userId(),
        entity: entity,
        collection: collection,
        date: new Date(),
        up: up
      };
      vote = Votes.findOne({
        user: this.userId(),
        entity: entity
      });
      if (vote) {
        Votes.update(vote._id, {
          $set: data
        });
      } else {
        Votes.insert(data);
      }
      if (collection === 'titles') {
        callback = function() {
          var achievement, best;
          achievement = Titles.findOne(entity).entity;
          best = Titles.findOne({
            entity: achievement
          }, {
            sort: {
              score: -1
            }
          });
          if (best) {
            return Achievements.update(achievement, {
              $set: {
                title: best.title
              }
            });
          }
        };
      }
      score = calculateScore(entity);
      return updateScore(table[collection], entity, score, callback);
    },
    accomplish: function(id, stry) {
      var a, acc;
      acc = Accomplishments.findOne({
        user: this.userId(),
        entity: id
      });
      if (acc) {
        return Accomplishments.update(acc._id, {
          $set: {
            story: stry,
            update: new Date()
          }
        });
      } else {
        Accomplishments.insert({
          user: this.userId(),
          entity: id,
          story: stry,
          score: 0,
          date: new Date()
        });
        a = Achievements.findOne(id);
        if (a) {
          return Meteor.users.update(this.userId(), {
            $inc: {
              score: a.score
            }
          });
        }
      }
    },
    updateUserScoreComplete: function() {
      var a, accs, entities, s, score;
      accs = Accomplishments.find({
        user: this.userId()
      });
      accs = accs.fetch();
      entities = _.pluck(accs, 'entity');
      a = Achievements.find({
        _id: {
          $in: entities
        }
      });
      a = a.fetch();
      s = _.pluck(a, 'score');
      score = _.reduce(s, function(memo, num) {
        return memo + num;
      }, 0);
      return updateScore(Meteor.users, this.userId(), score);
    }
  });

}).call(this);
